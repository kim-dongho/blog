---
title: "programmers-lv4-thievery-js"
koTitle: "[프로그래머스] Lv4. 도둑질 (JS)"
id: 5,
thumbnail: "/assets/icons/icon-programmers-dark.png"
date: "2024-10-10"
tags: ["JavaScript", "Algorithm", "Programmers", "Dynamic Programming"]
draft: false
summary: "도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다."
---

###

## 문제 설명

도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.

![img](https://grepp-programmers.s3.amazonaws.com/files/ybm/e7dd4f51c3/a228c73d-1cbe-4d59-bb5d-833fd18d3382.png)

각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.

각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

<br />

## 제한 사항

- 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
- money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

<br />

## 입출력 예

<table>
  <thead>
    <tr>
      <th>money</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[1, 2, 3, 1]</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<br />

## 고려사항

1. 배열에서 서로 인접해 있는 요소들 계산은 하지 않아야 함
2.

<br />

## 코드 설명

### #1

```jsx
const map = new Map();

for (const key of keymap) {
  key.split("").map((item, index) => {
    if (map.get(item) >= 0) {
      if (index < map.get(item)) {
        map.set(item, index);
      }
    } else {
      map.set(item, index);
    }
  });
}
```

keymap의 요소의 알파벳들을 전부 순회하여

map에 없을 경우: 삽입

map에 있을 경우: 비교하여 index가 빠르면 삽입

### #2

```jsx
for (const target of targets) {
  let count = 0;

  for (const item of target.split("")) {
    if (map.get(item) >= 0) {
      count += map.get(item) + 1;
    }
  }

  if (count === 0) answer.push(-1);
  else answer.push(count);
}
```

targets 요소의 알파벳들을 전부 순회하여 map에 있는 요소일 경우

해당 index값을 count에 더해 answer에 저장

count = 0 일 경우는 target에 없는 알파벳이라고 판단하여 answer에 -1을 저장

### #2 문제점

<table>
  <thead>
    <tr>
      <th>keymap</th>
      <th>targets</th>
      <th>result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>["ABC"]</td>
      <td>["AD"]</td>
      <td>[-1]</td>
    </tr>
    <tr>
      <td>["ABC"]</td>
      <td>["DA"]</td>
      <td>[-1]</td>
    </tr>
  </tbody>
</table>

해당 테스트 케이스 실행 결과 A는 존재하지만 D는 keymap에 없는 알파벳이라 -1을 출력해야 하지만

target을 전부 순회하므로 A의 인덱스 값이 들어가는 문제 발생

### #2 해결법

```jsx
for (const target of targets) {
  let count = 0;
  let flag = false;
  for (const item of target.split("")) {
    if (map.get(item) >= 0) {
      count += map.get(item) + 1;
    } else {
      flag = true;
    }
  }

  if (flag) answer.push(-1);
  else answer.push(count);
}
```

map에 없는 경우에는 keymap에 없는 데이터이기 때문에

flag를 이용해 target의 알파벳이 keymap에 존재하는지 확인하였음.

<br />

## 전체 코드

```jsx
function solution(money) {
  const money_front = [0, ...money.slice(0, -1)];
  const money_back = [0, ...money.slice(1)];
  let max_front = -1;
  let max_back = -1;

  if (money.length === 3) return Math.max(...money);

  for (let i = 0; i < money_front.length; i++) {
    if (i < 2) {
      max_front = Math.max(max_front, money_front[i]);
    } else {
      max_front = Math.max(max_front, money_front[i - 2] + money_front[i]);
    }
    money_front[i] = max_front;
  }

  for (let i = 0; i < money_back.length; i++) {
    if (i < 2) {
      max_back = Math.max(max_back, money_back[i]);
    } else {
      max_back = Math.max(max_back, money_back[i - 2] + money_back[i]);
    }
    money_back[i] = max_back;
  }

  return Math.max(max_front, max_back);
}
```
